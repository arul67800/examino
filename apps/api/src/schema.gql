# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input CreateHierarchyItemInput {
  color: String
  level: Float!
  name: String!
  parentId: String
  questionCount: Float! = 0
}

input CreateQuestionInputGQL {
  assertion: String
  createdBy: String
  difficulty: QuestionDifficulty = MEDIUM
  explanation: String
  hierarchyItemId: String!
  options: [QuestionOptionInput!]
  points: Float = 1
  question: String!
  reasoning: String
  tags: [String!]
  timeLimit: Float
  type: QuestionType!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type HierarchyItem {
  children: [HierarchyItem!]!
  color: String
  createdAt: DateTime!
  id: ID!
  level: Int!
  name: String!
  order: Int!
  parent: HierarchyItem
  parentId: ID
  questionCount: Int!
  type: String!
  updatedAt: DateTime!
}

type HierarchyStats {
  count: Int!
  level: Int!
  totalQuestions: Int!
  type: String!
}

type Mutation {
  """Create a new hierarchy item"""
  createHierarchyItem(input: CreateHierarchyItemInput!): HierarchyItem!
  createPost(authorId: String!, content: String, title: String!): Post!
  createQuestion(input: CreateQuestionInputGQL!): QuestionResponse!
  createUser(email: String!, name: String): User!

  """Delete a hierarchy item (only if it has no children)"""
  deleteHierarchyItem(id: ID!): Boolean!
  deleteQuestion(id: String!): Boolean!

  """Reorder multiple hierarchy items"""
  reorderHierarchyItems(items: [ReorderHierarchyItemInput!]!): [HierarchyItem!]!

  """Update an existing hierarchy item"""
  updateHierarchyItem(id: ID!, input: UpdateHierarchyItemInput!): HierarchyItem!
  updateQuestion(id: String!, input: UpdateQuestionInputGQL!): QuestionResponse!

  """Update the question count for a chapter (level 5 only)"""
  updateQuestionCount(count: Float!, id: ID!): HierarchyItem!
}

type PaginatedQuestionsResponse {
  page: Int!
  pages: Int!
  questions: [QuestionResponse!]!
  total: Int!
}

type Post {
  authorId: ID!
  content: String
  createdAt: DateTime!
  id: ID!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
}

type Query {
  getQuestion(id: String!): QuestionResponse!
  getQuestionByHumanId(humanId: String!): QuestionResponse!
  getQuestionsByHierarchy(hierarchyItemId: String!, limit: Int! = 20, page: Int! = 1): PaginatedQuestionsResponse!

  """Get a specific hierarchy item by ID"""
  hierarchyItem(id: ID!): HierarchyItem

  """Get all hierarchy items with nested children"""
  hierarchyItems: [HierarchyItem!]!

  """Get all hierarchy items at a specific level"""
  hierarchyItemsByLevel(level: Float!): [HierarchyItem!]!

  """Get all direct children of a parent hierarchy item"""
  hierarchyItemsByParent(parentId: ID!): [HierarchyItem!]!

  """Get statistics about the hierarchy structure"""
  hierarchyStats: [HierarchyStats!]!
  post(id: String!): Post
  posts: [Post!]!
  user(id: String!): User
  users: [User!]!
}

enum QuestionDifficulty {
  EASY
  HARD
  MEDIUM
}

type QuestionOption {
  createdAt: DateTime!
  id: ID!
  isCorrect: Boolean!
  order: Float!
  questionId: ID!
  text: String!
  updatedAt: DateTime!
}

input QuestionOptionInput {
  id: String
  isCorrect: Boolean!
  order: Float
  text: String!
}

type QuestionResponse {
  assertion: String
  createdAt: DateTime!
  createdBy: String
  difficulty: String!
  explanation: String
  hierarchyItemId: ID!
  humanId: String!
  id: ID!
  isActive: Boolean!
  options: [QuestionOption!]!
  points: Float!
  question: String!
  reasoning: String
  tags: [String!]!
  timeLimit: Float
  type: QuestionType!
  updatedAt: DateTime!
}

enum QuestionType {
  ASSERTION_REASONING
  MULTIPLE_CHOICE
  SINGLE_CHOICE
  TRUE_FALSE
}

input ReorderHierarchyItemInput {
  id: String!
  order: Float!
}

input UpdateHierarchyItemInput {
  color: String
  name: String
  order: Float
  questionCount: Float
}

input UpdateQuestionInputGQL {
  assertion: String
  difficulty: QuestionDifficulty
  explanation: String
  options: [QuestionOptionInput!]
  points: Float
  question: String
  reasoning: String
  tags: [String!]
  timeLimit: Float
  type: QuestionType
}

type User {
  createdAt: DateTime!
  email: String!
  id: ID!
  name: String
  updatedAt: DateTime!
}